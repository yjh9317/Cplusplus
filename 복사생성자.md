복사생성자
===================
복사생성자는 객체의 복사본을 생성할 때 호출되는 생성자이다.  
복사생성자에서도 얕은 복사와 깊은 복사, 그리고 묵시적 복사 생성자가 있다.

<br><br>
얕은 복사(shallow copy)
=================
클래스에서 복사생성자를 생성하지 않아도 묵시적인 복사생성자가 있는데  
그것이 바로 얕은 복사를 이용한 복사 생성자이다.  
<br><br>

class Person{    
  char* name;  
  int age;  
}  

int main()  
{  
  Person a("CheolSu",10);  
  Person b(a);  
}  
<br><br>
(멤버 변수를 받는 생성자가 있다고 하고)  
위와 같은 함수를 실행하면 b의 이름도 Cheolsu가 되고 나이도 10이 된다.  
하지만 여기서 문제점이 발생하는데 얕은복사는 원본 객체(a)의 변수들을 사본 객체(b)에 일대일로 복사하기 때문에   
1. 포인터로 가르키는 주소도 동일해지면서 a와 b의 이름을 공유하는 형태가 되면서 동시에  
2. 두 객체를 삭제해야하는데 같은 주소를 삭제하는 일이 두번 일어나기 때문에 런타임 오류가 발생한다.  

이러한 오류를 발생하는 것을 막기위해 포인터가 있다면 깊은 복사를 사용한다.  

<br><br>
깊은복사(deep copy)
==============
class Person{    
  char* name;  
  int age;  
<br>

public: 
Person(const Person& person){  
this->age= person.age;  
int len = strlen(person.name);  
this->name = new char [len+1];  
strcpy(this->name , person.name);  
}  

int main()  
{  
  Person a("CheolSu",10);  
  Person b(a);  
}  
<br><br>

얕은 복사와 다르게 깊은복사는 원본 객체를 받아주고 사본 객체의 포인터 변수들은 따로 동적할당하면서   
원본 객체의 변수들을 사본 객체에 넣어주는 식으로 함으로써 서로 다른 주소를 사용하도록 만들 수 있다.  


묵시적 복사 생성자
================
묵시적 복사생성자는 내가 명시적으로 복사생성자를 사용하지 않아도 컴파일러가 자동으로  
복사생성자를 호출한다.  
  <br><br>
  * 묵시적 복사생성자 종류<br><br>
    * 객체로 초기화 하여 객체가 생성될 때<br><br>
ex) Person a=b; 에서도 대입연산자가 아닌 복사생성자가 호출된다.<br><br>
    * 값에 의한 호출로 객체가 전달될 때<br><br>
    값에 의한 호출로 객체를 복사하여 함수에 전달한다.  
    만약 객체가 용량이 크다면 그만큼 복사하는데 사용하는 메모리가 많으므로  
    참조(&)를 이용하여 복사하는 메모리를 줄일 수 있다.<br><br>
    * 함수가 객체를 리턴할 때<br><br>
    함수가 객체를 리턴할 때 객체의 복사본을 생성하고 넘겨준다.  
